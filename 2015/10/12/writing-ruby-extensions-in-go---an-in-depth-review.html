<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Massimo Ronca ~ a reckless programmer with a sarcastic wit - Writing Ruby extensions in Go - an in depth review</title>

    <base href="http://massimoronca.it">

    
    <meta name="description" content="Welcome to Massimo Ronca website, this post is about: Ruby, Ruby extensions, Go shared objects, Ruby extensions in Go">
    

    <link rel="stylesheet" href="/assets/stylesheets/fonts.css">
    <link rel="stylesheet" href="/assets/stylesheets/styles.css">
    <link rel="stylesheet" href="/assets/stylesheets/highlight/solarized-dark.css">
    <link rel="stylesheet" href="/assets/stylesheets/gist/line-number-fix.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <link href="" rel="alternate" type="application/rss+xml" title="Massimo Ronca ~ a reckless programmer with a sarcastic wit" />

    <link rel="icon" type="image/png" href="/assets/images/icon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    

    <meta name="og:title" content="Writing Ruby extensions in Go - an in depth review">
    <meta name="og:type" content="website">
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header-title"><a href="/">Massimo Ronca</a></h1>

        <img src="/assets/images/massimoronca.png" class="logo" alt="Massimo Ronca">
        <p>This is not</p>
        <p>the programmer</p>
        <p>you're looking for</p>

     <footer>
       <a href="https://github.com/wstucco" title="Github"><img src="/assets/images/github-64.png" alt="Github" class="github-logo"> </a>
       <a href="https://twitter.com/wstucco" title="Twitter"><img src="/assets/images/twitter-64.png" alt="Twitter" class="twitter-logo"> </a>
       <a href="https://it.linkedin.com/in/massimoronca" title="Linkedin"><img src="/assets/images/linkedin-64.png" alt="Linkedin" class="linkedin-logo"> </a>
      </footer>
    </header>


  <section>
  <article id="content" class="post">
  <h1 class="post-title">Writing Ruby extensions in Go - an in depth review</h1>
  <div class="post-content">
    

<p>For a very long time the only way to extend Ruby with native estensions has been using <code>C</code>.<br />
I don&rsquo;t have the numbers with me, but I guess <code>C</code> is not the first choice for Ruby programmers when they have to pick up a secondary/complentary language.<br />
So I started investigating the possibility of writing them in other languages, taking advantage of the favorable moment: in the past 3-4 years we had an explosion of new languages that compile down to native code and can be easily used to produce a <code>C</code> equivalent shared library that Ruby can pick up and load.</p>

<p>My main goal was to find languages that a Ruby programmer would understand effortlessly or with a minimum investment.<br />
This first episode will focus on Go.</p>

<h2 id="you-will-need-go-1-5-or-above:e8d41cd2ae3d619118c1ce574d5f3b9a">You will need Go 1.5 or above</h2>

<p>Up until version 1.4, there was really no point in building a native extension in Go, you&rsquo;d have to create a <code>C</code> proxy function for every Go function being called, at the point that there was literally no benefit compared to writing everything in pure <code>C</code>.<br />
With version 1.5, Go made a step forward, introducing the support for building shared objects; this opens up a lot of new possibilities for writing shared code that gets executed outside the Go environment, including Ruby.</p>

<h2 id="done-in-60-seconds:e8d41cd2ae3d619118c1ce574d5f3b9a">Done in 60 seconds</h2>

<p>This is all your &ldquo;hello world&rdquo; extension will just be:</p>

<script src="https://gist.github.com/wstucco/7b0c424cf8dddbc8fd6a.js?file=hello_world.go"></script>

<p>Compile it with</p>

<script src="https://gist.github.com/wstucco/7b0c424cf8dddbc8fd6a.js?file=build.sh"></script>
    

<p>Have I already told you that <a href="https://github.com/ffi/ffi/wiki">FFI</a> is awesome?</p>

<script src="https://gist.github.com/wstucco/7b0c424cf8dddbc8fd6a.js?file=hello_world.rb"></script>

<p>There are a few things you need to pay attention to:</p>

<ul>
<li>It is better to put <code>import &quot;C&quot;</code> on its own line, separated from other imports, we&rsquo;ll see why in a moment<br /></li>
<li><code>//export</code> is a special <a href="https://golang.org/cmd/cgo/">Cgo</a> comment that instructs the compiler to emit a <code>C</code> function with the same name and parameters. The name of the exported <code>C</code> function must match the name of the Go function or it will fail. The comment must start exactly with <code>//export</code>, no spaces anywhere.</li>
<li>a <code>func main</code> is required, but then ignored</li>
</ul>

<h2 id="autarchy-or-writing-extensions-the-hard-way:e8d41cd2ae3d619118c1ce574d5f3b9a">Autarchy, or writing extensions the hard way</h2>

<p>This could be all, but of course it is not.<br />
Writing a Ruby extensions in a different language is one thing, writing it because the other language really offers some noticeable advantage, is entirely different.<br />
As a base for this series of articles, I will port the <a href="https://github.com/SamSaffron/fast_blank"><code>fast_blank</code></a> <code>C</code> extension.<br />
I&rsquo;ve chosen it for very simple reasons:</p>

<ul>
<li>it is deadly easy to port, even to languages that I&rsquo;m not particularly familiar with</li>
<li>it bundles a benchmark suite, so we can measure the performance gains/losses</li>
<li>it is real life code that&rsquo;s been downloaded a quarter million times so far</li>
</ul>

<blockquote>
<p>For the impatients: you can clone the <a href="https://github.com/mikamai/go_fast_blank">repo of the <code>go_fast_blank</code> gem on Github</a>.</p>
</blockquote>

<p>Even if <code>FFI</code> is great, it is still a dependency, that needs to be installed and maintained.<br />
<code>C</code> extensions are usually self contained and take advantage of the <code>MRI</code> <code>C</code> programming interface to build the necessary exported APIs.<br />
Go has a very good support for interfacing to <code>C</code> as you can see in this file</p>

<script src="https://gist.github.com/wstucco/7b0c424cf8dddbc8fd6a.js?file=go_fast_blank.go"></script>

<p>There are some new tricks here, that need an explanation.<br />
Just before <code>import &quot;C&quot;</code> we find what&rsquo;s called &ldquo;preamble&rdquo; by Cgo, and it&rsquo;s just <code>C</code> code that the compiler put at the beginning of the generated file, as it is, before starting the compilation.</p>

<blockquote>
<p><strong>IMPORTANT</strong>: there must be no empty line between the end of the preamble and the <code>import &quot;C&quot;</code> directive or the compilation will fail.<br />
that&rsquo;s the reason why I told you to put <code>import &quot;C&quot;</code> on its own line.</p>
</blockquote>

<p>In other words, the generated code will start with</p>

<script src="https://gist.github.com/wstucco/7b0c424cf8dddbc8fd6a.js?file=preamble.c"></script>

<p>You probably have guessed that the <code>C</code> prefix gives access to the <code>C</code> world directly from Go, with some added benefit: for example the <code>C.CString</code> converts Go native strings to <code>C</code> (<code>char*</code>) strings. This function allocates memory, so you <em>must</em> free the memory using <code>C.free</code>.</p>

<p>We do that in <code>defer C.free(unsafe.Pointer(cs))</code>, that tells Go to free the memory as soon as the surroinding function returns and is a very common pattern.<br />
The pointer to the string is declared as <code>unsafe.Pointer</code> because it does not belong to the Go world.</p>

<p>Another thing you might have noticed is the reverse twin function <code>C.GoString</code> that takes a <code>C</code> string and returns a Go string.  In this case no memory is allocated, the GC takes care of everything, so no freeing is required.</p>

<p>Some of the code just refers to the <code>MRI</code> programming interface, defined in <code>ruby.h</code> and related headers.<br />
For example <code>C.VALUE</code> is a macro for various types of pointers to data structures (from strings to function pointers) and <code>C.rb_define_method</code> defines a new method.<br />
It takes four parameters: the class to which the method belongs to (in this case <code>C.rb_cString</code> which is the Ruby equivalent of the builtin <code>String</code> class), the name of the method (in this case <code>blank?</code>) a callback and the number of arguments (zero in our case).</p>

<p>Basically we are writing something like</p>

<pre><code class="language-ruby">class String
    def blank?
    ...
    end
end
</code></pre>

<p>The third argument of <code>C.rb_define_method</code> is the <code>C</code> function that gets executed when the method is invoked on the Ruby side.<br />
The Go runtime and the <code>C</code> code are executed in different threads, with different stacks, it it prohibited to pass a pointer to Go code to <code>C</code>, so we can&rsquo;t take a pointer to a Go function and simly pass it to <code>C</code>, because it won&rsquo;t work.</p>

<p>There is a workaround, we can <code>//export</code> our Go function and pass the pointer to it instead, after casting it to <code>*[0]byte</code> (the Go equivalent of <code>void*</code>): <code>(*[0]byte)(C.go_fast_blank)</code>.<br />
There is only a small problem: <code>C.go_fast_blank</code> does not exists until the <code>C</code> files are compiled, so we cannot implicitly refer to it.<br />
We need to add a forward declaration to tell the compiler we know this function exists and it&rsquo;s imlpemented somewhere else outside here.<br />
That&rsquo;s what the line <code>extern inline VALUE go_fast_blank(VALUE);</code> is for, and it&rsquo;s a standar declaration for <code>rb_define_method</code> callbacks (<code>function_name(VALUE) -&gt; VALUE</code>).<br />
The rest is quite straightforward:</p>

<pre><code>gs := C.GoString(C.rb_string_value_cstr(&amp;s))
</code></pre>

<p>Take a <code>VALUE</code> convert it to a <code>C</code> string and then convert the result to a Go string.</p>

<pre><code>if gs == &quot;&quot; || strings.TrimLeftFunc(gs, unicode.IsSpace) == &quot;&quot; {
    return C.Qtrue
}

return C.Qfalse
</code></pre>

<p>If the string is empty or after removing all the unicode spaces on the left side, it is still empty, we found a blank string. Otherwise we return false.<br />
<code>Qtrue</code> and <code>Qfalse</code> are just two <code>C</code> #defines that map to a Ruby boolean.</p>

<p>Each extension has an <code>Init</code> function, and it&rsquo;s automatically called when the extension is <code>require</code>d.<br />
The name of the function must be <code>Init_#{extension_name}</code>, in our case <code>Init_go_fast_blank</code>.</p>

<p>Last but not least, to compile our self contained extension, we need to pass some flags to the compiler. We&rsquo;ll do it using a specific Cgo comment: <code>#cgo</code>.<br />
just before the <code>#include &quot;ruby.h&quot;</code> add these lines</p>

<pre><code class="language-C">
#cgo: CFLAGS: -I#{RbConfig::CONFIG['rubyhdrdir']} -I#{RbConfig::CONFIG['rubyarchhdrdir']}
#cgo: LDFLAGS: -L#{RbConfig::CONFIG['libdir']} #{RbConfig::CONFIG['LIBRUBYARG']}

</code></pre>

<p>The interpolation codes must be replaced with the actual value.<br />
I&rsquo;ve put it there for reference.<br />
Hint: the output must have <code>.bundle</code> extension and not <code>.so</code> as we did before, othewise Ruby will refuse to laod it.<br />
In the <a href="https://github.com/mikamai/go_fast_blank">repo of the <code>go_fast_blank</code> gem</a> you can find an ad hoc <code>extconf.rb</code> that will take care of everything.</p>

<h2 id="race-for-the-prize-https-www-youtube-com-watch-v-bs56ygzplqa:e8d41cd2ae3d619118c1ce574d5f3b9a"><a href="https://www.youtube.com/watch?v=bs56ygZplQA">Race for the prize</a></h2>

<p>Now we have a compiled, native, Ruby extension, launch <code>irb</code> and type</p>

<pre><code class="language-ruby">2.2.2 :001 &gt; require 'go_fast_blank'
go_fast_blank init
 =&gt; true 
</code></pre>

<p>You should see our extension announcing itself by printing <code>go_fast_blank init</code>.<br />
It&rsquo;s time to measure the performances and comment the results.<br />
After launching <code>benchmark</code>, the numbers are:</p>

<p><img src="http://i.imgur.com/4YddNT2.png" alt="Ruby VS Go" title="Ruby VS Go" /><br />
Go is between 2 and 4 times slower than the original Ruby implementation!</p>

<p><img src="http://i.imgur.com/48BOGlI.png" alt="GO, Y U SO SLOW" title="Y U SO SLOW?" /></p>

<p>Well, first of all Go is not only slower than Ruby, but it&rsquo;s plateuing, looks like the speed
of the Go extension is not influenced byt the length of the string, but it&rsquo;s just going as fast as it can,
and that is the fastest speed possible.<br />
A loss in performance was to be expected, Go generate code that interacts with its memory manager and scheduler, it is somewhat in between Java and compiled languages.<br />
But honestly actually running slower than Ruby code was a real surprise.<br />
According to this <a href="https://groups.google.com/forum/#!msg/golang-nuts/RTtMsgZi88Q/61hgyGSkWiQJ">Russ Cox answer</a>, calling <code>C</code> from Go has an aoverhead
similar to calling ten Go functions, looks like Go is one of those languages that can run faster ported code, than calling
the <code>C</code> implementation.<br />
If every function call counts for ten, it&rsquo;s no wonder that calling it thousands of time in a tight loop, would cause such
a tremendous loss in performances.<br />
To test this assumption, I moved the tight loop from Ruby to the Go extension: I ran the same comparison one thousand times
inside a Go loop and the same I did on the Ruby side.<br />
These are the new results:</p>

<p><img src="http://i.imgur.com/hCDdCfA.png" alt="Ruby VS Go updated" /></p>

<p>This time Go ran a bit faster, but with long strings the same slowness arises.<br />
I suspect the conversions routines from Ruby VALUE to Go strings are responsible for most of the overhead.<br />
Removing it from the equation gave me much better results (between 300 and 16 times faster than Ruby), but it&rsquo;s a low level optimization that makes sense only for three lines functions that are called over and over again, like this one.<br />
These numbers are not to be taken as a real benchmark, they are just the results of a micro benchmark and are not representetive of real performances in a real world application.
But they clearly show that running Go in a tight loop has a serious performance overhead, while if you delegate to
Go some heavy lifting work, it can give some performance boost.</p>

<h2 id="conclusions:e8d41cd2ae3d619118c1ce574d5f3b9a">Conclusions</h2>

<p>Writing Ruby extensions in Go, especially in conjunction with the great <code>FFI</code> library, can be real fun.<br />
You got the feeling of <em>&ldquo;scripting Ruby&rdquo;</em> without any of the drawbacks of writing low level <code>C</code> code.<br />
Writing completely auto contained extensions, it&rsquo;s a lot more work, but it&rsquo;s more tedious than hard.
The situation could improve vastly when someone will wrap the Ruby programming interface in a nice Go package to hide the <code>C</code> inheritance and maybe
write a <a href="https://blog.golang.org/generate"><code>go:generate</code></a> plugin to automate all the boilperplate code (for example
exporting the functions to <code>C</code>). But in the end it is still a lot easier than writing pure <code>C</code>.<br />
Perfomance wise though, I&rsquo;m doubtful that you could have some gain just by rewriting parts of you app in Go.<br />
It is in fact quite possibly the opposite.<br />
Go has a performance problem when intercating with <code>C</code> and it&rsquo;s by design.</p>

<p>However, there could be patterns where Go could be really helpful.<br />
I&rsquo;m sure Go channles and concurrency are worth exploring.<br />
Maybe in a next episode.</p>

  </div>
  <div class='small post-meta'>
    posted 
    on Monday, Oct 12 2015
  </div>
</article>

  </section>


    </div>
    <script src="/assets/javascripts/scale.fix.js"></script>
    <script src="/assets/javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1218157-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


    
    <script type="text/javascript" charset="UTF-8" src="http://chs02.cookie-script.com/s/64f1a8ad4d34d91e16260247ae88d42f.js"></script>
    
  </body>
</html>